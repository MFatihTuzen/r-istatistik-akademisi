---
title: "R Programlama'da Veri Tipleri"
author: "Dr. M. Fatih TÃ¼zen"
format:
  revealjs:
    theme: white
    slide-number: true
    self-contained: true
    footer: ğŸ“º R Programlama ve Ä°statistik Akademisi
    scrollable: true
execute:
  echo: true
  eval: true
  warning: false
  message: false
---

## GiriÅŸ: Râ€™de Veri Tiplerinin Ã–nemi

-   Her veri bir **tip** ile saklanÄ±r.
-   DoÄŸru veri tipi â†’ doÄŸru analiz, daha hÄ±zlÄ± hesaplama, daha az hata.
-   YanlÄ±ÅŸ veri tipi â†’ yanlÄ±ÅŸ sonuÃ§lar, beklenmedik hatalar.
-   Temel kontrol fonksiyonlarÄ±: `typeof()`, `class()`, `mode()`

```{r}

x <- 3.14
typeof(x)   # "double"
class(x)    # "numeric"
mode(x)     # "numeric"

y <- "3.14"
typeof(y)   # "character"
class(y)    # "character"
mode(y)     # "character"
```

### ğŸ’¡ Ä°pucu

-   `typeof()` â†’ ham tip, `class()` â†’ nesne tÃ¼rÃ¼.
-   GerÃ§ek depolama tipini Ã¶ÄŸrenmek iÃ§in **Ã¶nce `typeof()`**.

## Numeric (Double) ve Integer

-   **numeric (double)**: VarsayÄ±lan sayÄ±sal tip; hem ondalÄ±klÄ± hem tam sayÄ±lar **64-bit Ã§ift hassasiyetli (double precision)** olarak tutulur.
-   **integer**: **32-bit signed** (32 bit iÅŸaretli) tam sayÄ± tipidir; `L` eklenerek aÃ§Ä±kÃ§a atanÄ±r (`5L` gibi).

> **32-bit signed nedir?** 32 bit, bellekte bu deÄŸeri saklamak iÃ§in kullanÄ±lan alan miktarÄ±dÄ±r (4 byte). "Signed" ifadesi pozitif ve negatif sayÄ±larÄ± gÃ¶sterebildiÄŸini belirtir.\
> Bu tipte saklanabilecek deÄŸer aralÄ±ÄŸÄ±: $-2^{31}$ ile $2^{31} - 1$ arasÄ±ndadÄ±r.

### ğŸ’¡ Ä°pucu

Râ€™de yazdÄ±ÄŸÄ±nÄ±z `5` varsayÄ±lan olarak **double**â€™dÄ±r. Integer istiyorsanÄ±z sonuna **`L`** ekleyin: `42L`.

### Hassasiyet FarkÄ± (Floating-Point)

**Neden bÃ¶yle?** Double tipler sayÄ±larÄ± **ikilik (binary)** tabanda saklar. 0.1 ve 0.2 gibi bazÄ± ondalÄ±k sayÄ±lar ikilikte tam olarak ifade edilemez; bu yÃ¼zden toplandÄ±ÄŸÄ±nda 0.30000000000000004 gibi bir deÄŸer oluÅŸur.\

Bu nedenle eÅŸitlik karÅŸÄ±laÅŸtÄ±rmalarÄ±nda `all.equal()` veya tolerans kullanÄ±lÄ±r.

```{r}
0.1 + 0.2 == 0.3           # Ã§oÄŸu zaman FALSE
all.equal(0.1 + 0.2, 0.3)  # TRUE (tolerans ile)
```

### âš ï¸ Dikkat

-   Binary temsil nedeniyle bazÄ± ondalÄ±klar tam ifade edilemez.
-   Kesin eÅŸitlik yerine `all.equal()` gibi yÃ¶ntemleri tercih edin.

### DÃ¶nÃ¼ÅŸÃ¼m TuzaklarÄ±

```{r}
as.integer(3.9)    # 3  (kÄ±rpma; yuvarlama deÄŸil)
as.numeric(TRUE)   # 1
as.numeric(FALSE)  # 0
```

::: callout-note
## ğŸ” Not

`as.integer(3.9)` â†’ `3`; bu **yuvarlama deÄŸil**, ondalÄ±k kÄ±smÄ±n **atÄ±lmasÄ±dÄ±r**. Yuvarlama iÃ§in `round(3.9)`, aÅŸaÄŸÄ± yuvarlama iÃ§in `floor()`, yukarÄ± yuvarlama iÃ§in `ceiling()` kullanÄ±n.
:::

### Integerâ€™daki `L` Nedir?

-   `L` son eki, sayÄ±nÄ±n **integer literal** (tamsayÄ± sabiti) olarak oluÅŸturulmasÄ±nÄ± saÄŸlar: `5L`, `-12L`.
-   Râ€™de integerâ€™lar 32-bit signed tipindedir: aralÄ±k $-2^{31}$ ile $2^{31} - 1$.
-   Double ise Ã§ok daha geniÅŸ aralÄ±kta Ã§alÄ±ÅŸÄ±r ve $2^{53}$â€™e kadar tam sayÄ±larÄ± hatasÄ±z temsil edebilir.

### ğŸ§  Ä°pucu

-   BÃ¼yÃ¼k tam sayÄ± dizileri ve bellek hassasiyeti gereken durumlarda `integer` kullanmak avantajlÄ± olabilir.
-   Ancak R ekosisteminde Ã§oÄŸu fonksiyon **double** ile optimize edilmiÅŸtir; â€œerken optimizasyonâ€ yapmadan Ã¶nce Ã¶lÃ§Ã¼m yapÄ±n (`object.size()` gibi).

### Bellek KÄ±yaslamasÄ±

```{r}
x_int <- 1L:1e6               # integer vektÃ¶r
x_num <- as.numeric(1:1e6)    # double vektÃ¶r

typeof(x_int); object.size(x_int)
typeof(x_num); object.size(x_num)

```

## Character

-   Metin veya dize (string) verilerini saklamak iÃ§in kullanÄ±lÄ±r.
-   Tek (`' '`) veya Ã§ift (`" "`) tÄ±rnak ile tanÄ±mlanÄ±r.
-   SayÄ±sal iÅŸlemlerde kullanÄ±lamaz.

```{r}
x <- "Fatih"
y <- 'R Programlama'

typeof(x)   # "character"
class(x)    # "character"
```

### Ã–zellikler

-   Karakter vektÃ¶rleri yalnÄ±zca metin deÄŸerleri saklar.
-   VektÃ¶r iÃ§indeki tÃ¼m Ã¶ÄŸeler aynÄ± tiptedir (karakter).
-   TÃ¼r kontrolÃ¼: `typeof()`, `class()`.

```{r}
cities <- c("Ankara", "Ä°zmir", "Ä°stanbul")
typeof(cities)  # "character"
```

### FaktÃ¶r ile FarkÄ± (KÄ±sa)

-   **Character**: Metin olarak saklar.
-   **Factor**: Kategorik veriyi seviye (level) bilgisiyle saklar.

```{r}
city_char <- c("Ankara", "Ä°zmir")
city_fac  <- factor(city_char)

typeof(city_char)  # "character"
typeof(city_fac)   # "integer"
class(city_fac)    # "factor"
```

## Logical

-   MantÄ±ksal deÄŸerleri ifade eder: **TRUE** veya **FALSE**
-   `T` ve `F` kÄ±saltmalarÄ± kullanÄ±labilir (ama Ã¶nerilmez)
-   KarÅŸÄ±laÅŸtÄ±rma iÅŸlemleri ile elde edilir

```{r}
x <- 5
x > 3     # TRUE
x == 10   # FALSE
as.numeric(TRUE)   # 1
as.numeric(FALSE)  # 0
```

## Factor

-   Kategorik verileri temsil etmek iÃ§in kullanÄ±lÄ±r.
-   Ä°ki ana tÃ¼rÃ¼ vardÄ±r:
    -   **Nominal**: SÄ±rasÄ±z kategoriler (Ã¶r. ÅŸehir isimleri)
    -   **Ordinal**: SÄ±ralÄ± kategoriler (Ã¶r. kÃ¼Ã§Ã¼k \< orta \< bÃ¼yÃ¼k)
-   `factor()` fonksiyonu ile oluÅŸturulur.

```{r}
sizes <- factor(c("kÃ¼Ã§Ã¼k", "orta", "bÃ¼yÃ¼k", "orta"))
levels(sizes)  # "bÃ¼yÃ¼k" "kÃ¼Ã§Ã¼k" "orta"
```

### FaktÃ¶rlerin Depolanma BiÃ§imi

-   Bellekte faktÃ¶rler **integer** olarak saklanÄ±r.
-   Her kategoriye karÅŸÄ±lÄ±k gelen bir **seviye (level)** vardÄ±r.
-   `typeof()` â†’ "integer", `class()` â†’ "factor"

```{r}
typeof(sizes)  # "integer"
class(sizes)   # "factor"
```

### Ordinal FaktÃ¶rler

-   SÄ±ralÄ± kategorilerde `ordered = TRUE` kullanÄ±lÄ±r.
-   Seviyelerin sÄ±rasÄ± `levels` ile belirtilir.

```{r}
sizes_ord <- factor(c("kÃ¼Ã§Ã¼k", "orta", "bÃ¼yÃ¼k"), 
                    levels = c("kÃ¼Ã§Ã¼k", "orta", "bÃ¼yÃ¼k"),
                    ordered = TRUE)
```

## Veri Tipi DÃ¶nÃ¼ÅŸÃ¼mleri

-   ğŸ”„ Veri tipleri arasÄ±nda dÃ¶nÃ¼ÅŸÃ¼m iÃ§in `as.*()` fonksiyonlarÄ± kullanÄ±lÄ±r:
    -   `as.numeric()` â†’ sayÄ±sal
    -   `as.integer()` â†’ tam sayÄ±
    -   `as.character()` â†’ metin
    -   `as.logical()` â†’ mantÄ±ksal
    -   `as.factor()` â†’ faktÃ¶r
-   âš ï¸ Otomatik tip dÃ¶nÃ¼ÅŸÃ¼mÃ¼ (coercion) olabilir:
    -   `logical` \< `integer` \< `double` \< `character`

```{r}
as.numeric("42")     # 42
as.integer(3.9)      # 3 (kÄ±rpma)
as.character(3.14)   # "3.14"
as.logical(1)        # TRUE
```

### ğŸ›‘ FaktÃ¶rlerde DÃ¶nÃ¼ÅŸÃ¼m Dikkati

-   `as.numeric(factor)` â†’ ğŸ¯ **Seviye kodlarÄ±nÄ±** dÃ¶ner, etiketleri deÄŸil.
-   âœ… Etiketleri sayÄ±ya Ã§evirmek iÃ§in Ã¶nce karaktere dÃ¶nÃ¼ÅŸtÃ¼r:\
    `as.numeric(as.character(f))`

### ğŸ”€ Otomatik DÃ¶nÃ¼ÅŸÃ¼m (Coercion) Ã–rnekleri

```{r}
c(1, TRUE)     # 1 1 (logical â†’ numeric)
c("a", 1)      # "a" "1" (numeric â†’ character)
TRUE + TRUE    # 2
```

## ğŸ§© `is.*()` FonksiyonlarÄ±

-   Bir nesnenin **belirli bir veri tipine** veya **yapÄ±ya** sahip olup olmadÄ±ÄŸÄ±nÄ± kontrol eder.
-   SonuÃ§ olarak **TRUE** veya **FALSE** dÃ¶ner.
-   Ä°simleri genellikle `is.` ile baÅŸlar.

```{r}
x <- 5
is.numeric(x)   # TRUE
is.character(x) # FALSE

y <- "Merhaba"
is.character(y) # TRUE
is.factor(y)    # FALSE
```

ğŸ“Œ **SÄ±k KullanÄ±lanlar:**

-   `is.numeric()` â†’ SayÄ±sal mÄ±?
-   `is.integer()` â†’ Tam sayÄ± mÄ±?
-   `is.double()` â†’ OndalÄ±klÄ± sayÄ± mÄ±?
-   `is.character()` â†’ Karakter mi?
-   `is.factor()` â†’ FaktÃ¶r mÃ¼?
-   `is.logical()` â†’ MantÄ±ksal mÄ±?
-   `is.data.frame()` â†’ Veri Ã§erÃ§evesi mi?
-   `is.list()` â†’ Liste mi?
-   `is.matrix()` â†’ Matris mi?

## ğŸ“Œ Veri Tipleri â€“ Ã–zet

-   R'da temel veri tipleri: **numeric (integer, double)**, **character**, **logical**, **factor**.
-   `typeof()` â†’ Nesnenin temel tÃ¼rÃ¼nÃ¼ verir.
-   `class()` â†’ Nesnenin Ã¶zel sÄ±nÄ±fÄ±nÄ± verir.
-   `is.*()` fonksiyonlarÄ± â†’ Veri tipini kontrol eder.
-   FaktÃ¶rler â†’ Kategorik veri, integer tabanlÄ±.
-   Bellek boyutu ve deÄŸer aralÄ±klarÄ± veri tipine gÃ¶re deÄŸiÅŸir.
-   Veri tipi doÄŸru seÃ§ilmezse analiz ve hesaplama hatalarÄ± oluÅŸabilir.

## ğŸ“¢ Takip Etmeyi Unutma!

ğŸ“º YouTube KanalÄ±: [**R Programlama ve Ä°statistik Akademisi**](https://www.youtube.com/@RistatistikAkademi)\
ğŸ“˜ Kitap: [R Programlama](https://rprogramlama.netlify.app/)\
ğŸ“ Blog: [A Statisticianâ€™s R Notebook](https://mfatihtuzen.netlify.app/)\
ğŸ™ [GitHub Reposu](https://github.com/MFatihTuzen/r-istatistik-akademisi)
