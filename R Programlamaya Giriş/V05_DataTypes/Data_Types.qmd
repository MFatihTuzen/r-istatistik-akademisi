---
title: "Veri Tipleri"
author: "Dr. M. Fatih TÃ¼zen"
format:
  revealjs:
    theme: white
    slide-number: true
    self-contained: true
    footer: ğŸ“º R Programlama ve Ä°statistik Akademisi
    scrollable: true
execute:
  echo: true
  eval: true
  warning: false
  message: false
---

## GiriÅŸ: Râ€™de Veri Tiplerinin Ã–nemi

-   Her veri bir **tip** ile saklanÄ±r.
-   DoÄŸru veri tipi â†’ doÄŸru analiz, daha hÄ±zlÄ± hesaplama, daha az hata.
-   YanlÄ±ÅŸ veri tipi â†’ yanlÄ±ÅŸ sonuÃ§lar, beklenmedik hatalar.
-   Temel kontrol fonksiyonlarÄ±: `typeof()`, `class()`, `mode()`

```{r}

x <- 3.14
typeof(x)   # "double"
class(x)    # "numeric"
mode(x)     # "numeric"

y <- "3.14"
typeof(y)   # "character"
class(y)    # "character"
mode(y)     # "character"
```

### ğŸ’¡ Ä°pucu

-   `typeof()` â†’ ham tip, `class()` â†’ nesne tÃ¼rÃ¼.

-   GerÃ§ek depolama tipini Ã¶ÄŸrenmek iÃ§in **Ã¶nce `typeof()`**.

## Numeric (Double) ve Integer

-   **numeric (double)**: VarsayÄ±lan sayÄ±sal tip; hem ondalÄ±klÄ± hem tam sayÄ±lar **64-bit Ã§ift hassasiyetli (double precision)** olarak tutulur.
-   **integer**: **32-bit signed** (32 bit iÅŸaretli) tam sayÄ± tipidir; `L` eklenerek aÃ§Ä±kÃ§a atanÄ±r (`5L` gibi).

> **32-bit signed nedir?** 32 bit, bellekte bu deÄŸeri saklamak iÃ§in kullanÄ±lan alan miktarÄ±dÄ±r (4 byte). "Signed" ifadesi pozitif ve negatif sayÄ±larÄ± gÃ¶sterebildiÄŸini belirtir.\
> Bu tipte saklanabilecek deÄŸer aralÄ±ÄŸÄ±: $-2^{31}$ ile $2^{31} - 1$ arasÄ±ndadÄ±r.

### ğŸ’¡ Ä°pucu

Râ€™de yazdÄ±ÄŸÄ±nÄ±z `5` varsayÄ±lan olarak **double**â€™dÄ±r. Integer istiyorsanÄ±z sonuna **`L`** ekleyin: `42L`.

### Hassasiyet FarkÄ± (Floating-Point)

**Neden bÃ¶yle?** Double tipler sayÄ±larÄ± **ikilik (binary)** tabanda saklar. 0.1 ve 0.2 gibi bazÄ± ondalÄ±k sayÄ±lar ikilikte tam olarak ifade edilemez; bu yÃ¼zden toplandÄ±ÄŸÄ±nda 0.30000000000000004 gibi bir deÄŸer oluÅŸur.\

Bu nedenle eÅŸitlik karÅŸÄ±laÅŸtÄ±rmalarÄ±nda `all.equal()` veya tolerans kullanÄ±lÄ±r.

```{r}
0.1 + 0.2 == 0.3           # Ã§oÄŸu zaman FALSE
all.equal(0.1 + 0.2, 0.3)  # TRUE (tolerans ile)
```

### âš ï¸ Dikkat

-   Binary temsil nedeniyle bazÄ± ondalÄ±klar tam ifade edilemez.

-   Kesin eÅŸitlik yerine `all.equal()` gibi yÃ¶ntemleri tercih edin.

### DÃ¶nÃ¼ÅŸÃ¼m TuzaklarÄ±

```{r}
as.integer(3.9)    # 3  (kÄ±rpma; yuvarlama deÄŸil)
as.numeric(TRUE)   # 1
as.numeric(FALSE)  # 0
```

::: callout-note
## ğŸ” Not

`as.integer(3.9)` â†’ `3`; bu **yuvarlama deÄŸil**, ondalÄ±k kÄ±smÄ±n **atÄ±lmasÄ±dÄ±r**. Yuvarlama iÃ§in `round(3.9)`, aÅŸaÄŸÄ± yuvarlama iÃ§in `floor()`, yukarÄ± yuvarlama iÃ§in `ceiling()` kullanÄ±n.
:::

### Integerâ€™daki `L` Nedir?

-   `L` son eki, sayÄ±nÄ±n **integer literal** (tamsayÄ± sabiti) olarak oluÅŸturulmasÄ±nÄ± saÄŸlar: `5L`, `-12L`.

-   Râ€™de integerâ€™lar 32-bit signed tipindedir: aralÄ±k $-2^{31}$ ile $2^{31} - 1$.

-   Double ise Ã§ok daha geniÅŸ aralÄ±kta Ã§alÄ±ÅŸÄ±r ve $2^{53}$â€™e kadar tam sayÄ±larÄ± hatasÄ±z temsil edebilir.

### ğŸ§  Ä°pucu

-    BÃ¼yÃ¼k tam sayÄ± dizileri ve bellek hassasiyeti gereken durumlarda `integer` kullanmak avantajlÄ± olabilir.

-   Ancak R ekosisteminde Ã§oÄŸu fonksiyon **double** ile optimize edilmiÅŸtir; â€œerken optimizasyonâ€ yapmadan Ã¶nce Ã¶lÃ§Ã¼m yapÄ±n (`object.size()` gibi).

### Bellek KÄ±yaslamasÄ±

```{r}
x_int <- 1L:1e6               # integer vektÃ¶r
x_num <- as.numeric(1:1e6)    # double vektÃ¶r

typeof(x_int); object.size(x_int)
typeof(x_num); object.size(x_num)

```

## ğŸ“¢ Takip Etmeyi Unutma!

ğŸ“º YouTube KanalÄ±: [**R Programlama ve Ä°statistik Akademisi**](https://www.youtube.com/@RistatistikAkademi)\
ğŸ“˜ Kitap: [R Programlama](https://rprogramlama.netlify.app/)\
ğŸ“ Blog: [A Statisticianâ€™s R Notebook](https://mfatihtuzen.netlify.app/)\
ğŸ™ [GitHub Reposu](https://github.com/MFatihTuzen/r-istatistik-akademisi)
